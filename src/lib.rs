//
// simple helpers for gcd
//
pub fn gcd(mut m: usize, mut n: usize) -> usize {
    assert!(m != 0 && n != 0);
    while m > 0 {
        if m < n {
            let t = m;
            m = n;
            n = t;
        }
        m = m % n;
    }
    n
}
pub fn gcd_vec(numbers: &[usize]) -> usize {
    let mut d = numbers[0];
    for m in &numbers[1..] {
        d = gcd(d, *m);
    }
    d
}
//
// simple struct to hold the results
//
pub struct Semigroup {
    pub e:usize,
    pub f:usize,
    pub m:usize,
    pub count_set:usize,
    pub count_gap:usize,
}
//
// compute the numerical semigroup generated by the numbers in the slice "input"
//
pub fn compute(input: &[usize]) -> Semigroup {
    let d = gcd_vec(input);
    let mut inputnumbers: Vec<usize> = input.iter().map(|x| (x / d) as usize).collect();
    inputnumbers.sort();

    let maximal_input: usize = *inputnumbers.last().unwrap();
    let width=2*maximal_input;
    let m: usize = *inputnumbers.first().unwrap();

    let mut aperyset: Vec<usize> = vec![0; m];
    let mut count_set = 1usize; // 0 is already an element in this set
    let mut window = vec![-1isize; width]; // here we store the results
    let mut windowindex = m; // this is the running index
    let mut runlength = 0usize; // number of consecutive hits
    let mut hit: bool = false; // true if the number windowindex is in S
    let mut max_apery:usize = m;
    let mut sum_apery:usize = 0;
    let mut minimal_generators:usize = 1;
    let mut max_atom = m;
    let mut genset:Vec<usize> = Vec::new();
    window[0]=0;
    let mut i: usize = m; // startindex
    while runlength < m {
        let residue = i % m;
        if 0 == residue {
            // case: a multiple of m
            count_set += 1;
            runlength += 1;
            hit = true;
            window[windowindex] = i as isize;
        } else if aperyset[residue]>0 && i > aperyset[residue] {
            // case: we already have found an element in this residue class
            count_set += 1;
            runlength += 1;
            hit = true;
            window[windowindex] = i as isize;
        }
        else {
            // ok, we must ckeck this number by going back to windowindex-generator for all generators
            for k in inputnumbers[1..].iter() {
                if windowindex >= *k && window[windowindex - k] >= 0 {
                    // case window[windowindex - k] is already an element of S
                    count_set += 1;
                    runlength += 1;
                    hit = true;
                    window[windowindex] = i as isize;
                    aperyset[residue] = i;
                    sum_apery+=i;
                    if i>max_apery { max_apery = i}
                    if 0==window[windowindex - *k] {
                        minimal_generators+=1;
                        genset.push(i);
                        if max_atom < i {max_atom=i};
                    }
                    break;
                }
            }
        }
        if !hit { runlength = 0 };
        hit = false;
        i += 1;
        //
        // copy the right half of the window to the left and continue
        //
        if windowindex == width - 1 {
            let (dst, src) = window.split_at_mut(maximal_input);
            dst[0..maximal_input].clone_from_slice(&src[..maximal_input]);
            windowindex = maximal_input;
        } else {
            windowindex += 1;
        }
    }
    genset.push(m);
    assert_eq!(genset.len(),minimal_generators);
    Semigroup{
        e:minimal_generators,
        f:max_apery-m,
        m:m,
        count_set:count_set-m,
        count_gap:(sum_apery - ((m - 1) * m) / 2) / m,
    }
}